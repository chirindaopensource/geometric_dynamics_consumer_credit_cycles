# -*- coding: utf-8 -*-
"""acquire_and_clean_fred_data.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fnxQmsUbrpTI_s7h3p031mLcoIPxe9r3
"""

# Install Essential Modules

!pip install fredapi
!pip install pandas
!pip install numpy
!pip install typing
!pip install warnings

# Import Essential Modules

import pandas as pd
import numpy as np
from typing import List, Dict
from fredapi import Fred
import warnings

# Helper Functions

def fetch_and_prepare_fred_quarterly_data(
    api_key: str,
    series_ids: List[str] = None
) -> pd.DataFrame:
    """
    Fetch FRED economic data series and construct a quarterly-frequency DataFrame
    with proper aggregation rules for regime diagnostic modeling.

    This function implements a rigorous data pipeline for economic time series:
    1. Authenticates with FRED API and downloads monthly series
    2. Applies series-specific quarterly aggregation (mean vs end-of-period)
    3. Constructs a synchronized quarterly DataFrame with quarter-end dates
    4. Cleans data by replacing infinities, forward-filling, and dropping nulls

    Parameters
    ----------
    api_key : str
        Federal Reserve Economic Data (FRED) API key. Obtain from:
        https://fred.stlouisfed.org/docs/api/api_key.html
    series_ids : List[str], optional
        List of FRED series identifiers to fetch. Default is:
        ["UNRATE", "PCE", "PSAVERT", "REVOLSL", "CORCACBS"]

    Returns
    -------
    pd.DataFrame
        Quarterly-frequency DataFrame with DatetimeIndex (quarter-end dates).
        Columns correspond to input series_ids in the same order.
        - UNRATE: Unemployment rate (%), quarterly average
        - PCE: Personal consumption expenditures (billions $), quarterly average
        - PSAVERT: Personal saving rate (%), quarterly average
        - REVOLSL: Revolving consumer credit (billions $), end-of-quarter
        - CORCACBS: Charge-off rate on consumer loans (%), quarterly

    Raises
    ------
    ValueError
        If api_key is empty/None or series_ids list is empty
    ConnectionError
        If FRED API authentication fails
    KeyError
        If any series_id is not found in FRED database

    Notes
    -----
    - All monetary series retain their native FRED units (billions of dollars)
    - Percentage series are in percent units (not decimal)
    - No forward-looking operations; quarterly aggregation uses only data
      from within each quarter
    - Level series (PCE, REVOLSL) are stored as-is; growth transformations
      occur in downstream preprocessing

    Examples
    --------
    >>> df = fetch_and_prepare_fred_quarterly_data(api_key="your_key_here")
    >>> df.head()
                UNRATE      PCE  PSAVERT   REVOLSL  CORCACBS
    2006-12-31    4.5  11250.3      3.2    1065.2      2.01
    2007-03-31    4.5  11340.8      3.1    1080.5      2.15
    """
    # Validate API key input
    if not api_key or not isinstance(api_key, str):
        raise ValueError(
            "api_key must be a non-empty string. "
            "Obtain a FRED API key from https://fred.stlouisfed.org/docs/api/api_key.html"
        )

    # Set default series list if not provided
    if series_ids is None:
        series_ids = ["UNRATE", "PCE", "PSAVERT", "REVOLSL", "CORCACBS"]

    # Validate series_ids input
    if not series_ids or not isinstance(series_ids, list):
        raise ValueError("series_ids must be a non-empty list of FRED series identifiers")

    if not all(isinstance(s, str) for s in series_ids):
        raise ValueError("All elements in series_ids must be strings")

    # Initialize FRED API client
    fred_client = _initialize_fred_client(api_key)

    # Define aggregation rules: which series use quarterly average vs end-of-quarter
    aggregation_rules: Dict[str, str] = {
        'UNRATE': 'QuarterlyAverage',
        'PSAVERT': 'QuarterlyAverage',
        'PCE': 'QuarterlyAverage',
        'REVOLSL': 'QuarterEnd',
        'CORCACBS': 'QuarterEnd'  # Already quarterly, but standardize frequency
    }

    # Fetch monthly series and store in list
    monthly_series_list: List[pd.Series] = []
    for series_id in series_ids:
        # Download monthly data from FRED
        monthly_series = _fetch_monthly_series(fred_client, series_id)
        monthly_series_list.append(monthly_series)

    # Convert each monthly series to quarterly using appropriate aggregation
    quarterly_series_list: List[pd.Series] = []
    for series_id, monthly_series in zip(series_ids, monthly_series_list):
        # Determine aggregation method for this series
        aggregation_method = aggregation_rules.get(series_id, 'QuarterlyAverage')

        # Apply quarterly aggregation
        if aggregation_method == 'QuarterlyAverage':
            quarterly_series = _aggregate_to_quarterly_average(monthly_series, series_id)
        elif aggregation_method == 'QuarterEnd':
            quarterly_series = _aggregate_to_quarterly_end(monthly_series, series_id)
        else:
            raise ValueError(f"Unknown aggregation method '{aggregation_method}' for {series_id}")

        quarterly_series_list.append(quarterly_series)

    # Concatenate all quarterly series into a single DataFrame
    df_quarterly = pd.concat(
        quarterly_series_list,
        axis=1,  # Column-wise concatenation
        join='outer'  # Preserve all timestamps across series
    )

    # Ensure column names match input series_ids
    df_quarterly.columns = series_ids

    # Clean the DataFrame: replace infinities, forward fill, drop nulls
    df_cleaned = _clean_dataframe(df_quarterly)

    return df_cleaned


def _initialize_fred_client(api_key: str) -> Fred:
    """
    Initialize and validate FRED API client.

    Parameters
    ----------
    api_key : str
        FRED API authentication key

    Returns
    -------
    Fred
        Authenticated FRED client object

    Raises
    ------
    ConnectionError
        If API client initialization fails
    """
    try:
        # Create FRED API client instance
        fred_client = Fred(api_key=api_key)
        return fred_client
    except Exception as e:
        raise ConnectionError(
            f"Failed to initialize FRED API client. "
            f"Verify your API key is valid. Error: {str(e)}"
        ) from e


def _fetch_monthly_series(
    fred_client: Fred,
    series_id: str
) -> pd.Series:
    """
    Fetch a single economic time series from FRED at monthly frequency.

    Parameters
    ----------
    fred_client : Fred
        Authenticated FRED API client
    series_id : str
        FRED series identifier (e.g., 'UNRATE', 'PCE')

    Returns
    -------
    pd.Series
        Time series with DatetimeIndex, named by series_id

    Raises
    ------
    KeyError
        If series_id is not found in FRED database
    ValueError
        If downloaded series is empty or invalid

    Notes
    -----
    - Requests entire available history for the series
    - Returned series may have irregular frequency or missing values
    - Native FRED units are preserved (no transformations applied)
    """
    try:
        # Download series data from FRED (returns pandas Series)
        series_data = fred_client.get_series(series_id)

        # Validate that data was returned
        if series_data is None or len(series_data) == 0:
            raise ValueError(f"Series {series_id} returned empty data from FRED")

        # Ensure index is DatetimeIndex
        if not isinstance(series_data.index, pd.DatetimeIndex):
            series_data.index = pd.to_datetime(series_data.index)

        # Set series name to the FRED identifier
        series_data.name = series_id

        return series_data

    except Exception as e:
        if "Bad Request" in str(e) or "404" in str(e):
            raise KeyError(
                f"Series '{series_id}' not found in FRED database. "
                f"Verify the series ID at https://fred.stlouisfed.org/"
            ) from e
        else:
            raise ValueError(
                f"Error fetching series '{series_id}' from FRED: {str(e)}"
            ) from e


def _aggregate_to_quarterly_average(
    monthly_series: pd.Series,
    series_id: str
) -> pd.Series:
    """
    Aggregate monthly time series to quarterly frequency using arithmetic mean.

    This aggregation is appropriate for flow variables and rates where the
    quarterly value represents the average condition during the quarter.

    Parameters
    ----------
    monthly_series : pd.Series
        Monthly-frequency time series with DatetimeIndex
    series_id : str
        Series identifier (for naming output)

    Returns
    -------
    pd.Series
        Quarterly-frequency series with quarter-end DatetimeIndex.
        Each value is the arithmetic mean of monthly values within that quarter.

    Notes
    -----
    - Uses pandas 'QE' (Quarter End) frequency for Dec 31, Mar 31, Jun 30, Sep 30 dates
    - Partial quarters (fewer than 3 months) are included with available data
    - No forward-looking bias: only uses data from within each quarter

    Examples
    --------
    For a quarter with monthly values [4.5, 4.6, 4.5], the quarterly value is 4.533
    """
    # Resample to quarter-end frequency and compute mean of monthly values
    quarterly_series = monthly_series.resample('QE').mean()

    # Preserve series name
    quarterly_series.name = series_id

    return quarterly_series


def _aggregate_to_quarterly_end(
    monthly_series: pd.Series,
    series_id: str
) -> pd.Series:
    """
    Aggregate monthly time series to quarterly frequency using end-of-quarter value.

    This aggregation is appropriate for stock variables where the quarterly value
    represents the state at the end of the quarter (last month).

    Parameters
    ----------
    monthly_series : pd.Series
        Monthly-frequency time series with DatetimeIndex
    series_id : str
        Series identifier (for naming output)

    Returns
    -------
    pd.Series
        Quarterly-frequency series with quarter-end DatetimeIndex.
        Each value is the last available monthly value in that quarter.

    Notes
    -----
    - Uses pandas 'QE' (Quarter End) frequency for Dec 31, Mar 31, Jun 30, Sep 30 dates
    - Takes the last (most recent) monthly observation within each quarter
    - For stock variables like credit outstanding, this represents end-of-period balance
    - No forward-looking bias: uses only the final month of each quarter

    Examples
    --------
    For a quarter with monthly values [1065.2, 1070.5, 1075.8],
    the quarterly value is 1075.8 (last month)
    """
    # Resample to quarter-end frequency and take last monthly value
    quarterly_series = monthly_series.resample('QE').last()

    # Preserve series name
    quarterly_series.name = series_id

    return quarterly_series


def _clean_dataframe(df: pd.DataFrame) -> pd.DataFrame:
    """
    Clean economic time series DataFrame by handling infinities and missing values.

    Implements a three-stage cleaning protocol:
    1. Replace infinite values with NaN (infinities are non-physical for economic data)
    2. Forward-fill NaN values (use last valid observation, no forward-looking bias)
    3. Drop any remaining rows with NaN (incomplete observations)

    Parameters
    ----------
    df : pd.DataFrame
        Quarterly-frequency DataFrame with potential inf/NaN values

    Returns
    -------
    pd.DataFrame
        Cleaned DataFrame with no inf or NaN values

    Notes
    -----
    - Forward filling is appropriate for economic time series as it assumes
      persistence without introducing forward-looking bias
    - Remaining NaN after forward fill indicates no prior valid data exists
    - Row-wise deletion ensures all features have valid values at each timestamp

    Warnings
    --------
    If substantial data is dropped, a warning is issued indicating potential
    data quality issues or series misalignment
    """
    # Record original shape for diagnostics
    original_rows = len(df)

    # Stage 1: Replace positive and negative infinities with NaN
    # Economic data should not contain infinite values (indicates computation error)
    df_cleaned = df.replace([np.inf, -np.inf], np.nan)

    # Stage 2: Forward fill missing values
    # Use last valid observation carried forward (LOCF) - no forward-looking bias
    df_cleaned = df_cleaned.ffill()

    # Stage 3: Drop any remaining rows with NaN values
    # These represent periods where no prior valid data exists
    df_cleaned = df_cleaned.dropna()

    # Diagnostic: warn if substantial data loss occurred
    final_rows = len(df_cleaned)
    rows_dropped = original_rows - final_rows

    if rows_dropped > 0:
        pct_dropped = 100.0 * rows_dropped / original_rows
        if pct_dropped > 10.0:
            warnings.warn(
                f"Data cleaning dropped {rows_dropped} rows ({pct_dropped:.1f}% of data). "
                f"This may indicate data quality issues or series misalignment. "
                f"Verify FRED series have overlapping time coverage.",
                UserWarning
            )

    return df_cleaned

# Download Data

api_key = "your_fred_api_key_here"
df = fetch_and_prepare_fred_quarterly_data(api_key)
print(df.head())
print(f"\nShape: {df.shape}")
print(f"Date range: {df.index.min()} to {df.index.max()}")
print(f"Frequency: {df.index.freq}")

# Save Data

df.to_csv("consolidated_df_raw.csv")

# Read CSV

# consolidated_df_raw = pd.read_csv("consolidated_df_raw.csv", index_col=0, parse_dates=True)
# consolidated_df_raw.index.name = "Date"
# consolidated_df_raw.head()